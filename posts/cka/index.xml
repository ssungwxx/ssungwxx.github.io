<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CKA study on SugnwooKim's place</title><link>https://ssungwxx.github.io/posts/cka/</link><description>Recent content in CKA study on SugnwooKim's place</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 14 Jul 2021 23:55:29 +0900</lastBuildDate><atom:link href="https://ssungwxx.github.io/posts/cka/index.xml" rel="self" type="application/rss+xml"/><item><title>2-10 Replicasets</title><link>https://ssungwxx.github.io/posts/cka/2-10-recap-replicasets/</link><pubDate>Wed, 14 Jul 2021 23:55:29 +0900</pubDate><guid>https://ssungwxx.github.io/posts/cka/2-10-recap-replicasets/</guid><description>Replication controller 만약 우리가 pod 하나를 운영하고 있다고 가정해보자. 만약 해당 pod가 죽어서 접근이 불가능해지면 어떻게 될까? 사용자들이 접근을 하지 못하게 될 것이고 다른 pod가 실행 되어야할 것이다. 이렇게 다른</description></item><item><title>2-9 Pods With Yaml</title><link>https://ssungwxx.github.io/posts/cka/2-9-pods-with-yaml/</link><pubDate>Thu, 24 Jun 2021 23:44:29 +0900</pubDate><guid>https://ssungwxx.github.io/posts/cka/2-9-pods-with-yaml/</guid><description>Kubernetes yaml 형식 apiVersion: kind: metadata: spec: 일반적인 yaml형식은 위와같다.
apiVersion: 사용하려는 오브젝트에 따라 다르게 기술된다. 대표적인 예시는 다음과 같다. kind Version Pod v1 Service v1 ReplicaSet apps/v1 Deployment apps/v1 kind: 생성할 오브젝트의 타입을 지정한다. 여기에서는 pod를 만들거기에 pod라 기술한다. 위 표에서 왼쪽 필드에 있는 오브젝트들이 여기에 해당한다.
metadata: 위에서 소개된 2가지와는 다르게 string 타입이 아닌 dictionary타입이 기술된다.</description></item><item><title>2-8 Pod</title><link>https://ssungwxx.github.io/posts/cka/2-8-pod/</link><pubDate>Thu, 24 Jun 2021 22:57:56 +0900</pubDate><guid>https://ssungwxx.github.io/posts/cka/2-8-pod/</guid><description>Pod 쿠버네티스는 컨테이너를 노드에서 바로 배포하지않는다. 컨테이너들은 pod라고 알려진 단위로 캡슐화되어 배포한다. 이 pod는 쿠버네티스에서 가장 작은 단위를 의미한다.
Pod가 인스턴스가 되어 생성될 때, 같은 컨테이너를 더 배포하고 싶다면 어떻게 할까? pod안에 공간을 늘리는게 아닌 새로은 pod를 생성한다. 그래서 이 pod들을 생성할 수도 있고, 제거할 수도 있다.
보통 pod는 한개의 컨테이너와 관계를 맺는다. 하지만 사실 pod는 여러 컨테이너를 가지는 단위가 될 수도 있다. 만약 컨테이너를 배포할 때 helper conatiner라고 불리는 앱 배포를 위한 다른 컨테이너가 필요할 때, multi-container pod라 불리는 해당 방법을 사용하기도 한다.</description></item><item><title>2-7 Kube Proxy</title><link>https://ssungwxx.github.io/posts/cka/2-7-kube-proxy/</link><pubDate>Thu, 24 Jun 2021 21:50:10 +0900</pubDate><guid>https://ssungwxx.github.io/posts/cka/2-7-kube-proxy/</guid><description>Kube proxy 클러스터 내부에서 pod는 다른 pod들과 통신을 할 수 있다. 클러스터 내부의 가상 네트워크를 사용해서 pod들끼리 통신이 가능하다.
만약 웹서비스를 배포하였을 때, 한쪽에는 서비스를 다른 한쪽에는 DB를 배포했다고 하자. 이 때, 서비스는 DB를 사용하기 위해 접속을 시도할텐데 DB의 접속 정보가 언제나 똑같다는 보장이 없다. 그래서 우리는 DB를 사용하기 Service를 생성한다. 서비스는 pod를 사용하기 위해 ip나 이름을 통해 접근할 것이다.
그럼 서비스는 어떻게 pod에 접근하고 사용하는 것일까? 서비스는 실제로 pod가 속한 네트워크에 접속하지는 못한다.</description></item><item><title>2-6 Kubelet</title><link>https://ssungwxx.github.io/posts/cka/2-6-kubelet/</link><pubDate>Thu, 24 Jun 2021 21:24:07 +0900</pubDate><guid>https://ssungwxx.github.io/posts/cka/2-6-kubelet/</guid><description>Kubelet Kubelet은 선박들의 함장과 같은 역할을한다. 마스터 노드의 스케쥴러와 통신하며 어떻게 컨테이너들을 실을지 결정하고 배의 상태(Pod들의 상태)를 주기적으로 알려준다.
Kube-scheduler에게서 Node 등록에 관한 명령을 받게되면 kubelet은 POD를 생성하고 Conatainer engine(보통 Docker)에 이미지를 실행하고 인스턴스를 생성한다.
그리고 Kubelet은 컨테이너의 상태를 모니터링하고 그에 관한 내용을 kube-api로 보내준다.</description></item><item><title>2-5 Kube Scheduler</title><link>https://ssungwxx.github.io/posts/cka/2-5-kube-scheduler/</link><pubDate>Fri, 11 Jun 2021 01:26:33 +0900</pubDate><guid>https://ssungwxx.github.io/posts/cka/2-5-kube-scheduler/</guid><description>Kube Secheduler 앞서 이야기했듯이 Kuber scheduler는 노드에 pod에 스케쥴링하는 작업을 담당한다. 여기서 명심해야 할 것은 scheduler는 pod가 어느 노드로 갈지만 결정한다. pod를 생성하는 것과 같은 역할은 kubelet이 담당한다.
좀 더 자세히 말하자면, 다양한 컨테이너들이 노드위에 적재될 때, 각각 다른 사이즈가 존재할 것이다. 사용자는 당연히 좀 더 효율적인 분배를 원할 것이고 이러한 역할을 scheduler가 담당한다.
만약 일정양이 필요한 작업이 있고 노드가 여러개 존재한다면 scheduler는 2가지 작업으로 해당 컨테이너를 적절한 노드에 배치한다.</description></item><item><title>2-4 Kube Controller Manager</title><link>https://ssungwxx.github.io/posts/cka/2-4-kube-controller-manager/</link><pubDate>Fri, 11 Jun 2021 01:17:14 +0900</pubDate><guid>https://ssungwxx.github.io/posts/cka/2-4-kube-controller-manager/</guid><description>Kube controller manager 쿠버네티스에는 사무실이나 부서 역할을 담당하는 다양한 컨트롤러들이 존재한다. 컨트롤러는 종류에 따라 배들을 모니터링 하기도하고 컨테이너를 확인하고 돌보기도한다.
이러한 컨트롤러들은 역시나 모두 **kube api server**를 통해 통신한다.
Namespace controller, Deployment Controller, Endpoint controller 등 다양한 컨트롤러들이 있는데 이러한 컨트롤러들을 모두 관리하는 것이 kube controller manager이다.
Kube controller manager는 직접 다운로드 받아 배포할 수도 잇지만, kubeadm을 통해 쿠버네티스를 설정하면 kube-system 네임스페이스에 kube-controller-manager-master 이라는 이름으로 배포된다.</description></item><item><title>2-3 Kube Api Server</title><link>https://ssungwxx.github.io/posts/cka/2-3-kube-api-server/</link><pubDate>Tue, 08 Jun 2021 13:22:59 +0900</pubDate><guid>https://ssungwxx.github.io/posts/cka/2-3-kube-api-server/</guid><description>Kube-api server 앞쪽에서 설명했듯이 Kube api server는 쿠버네티스의 컴포넌트들을 관리하는 역할을 한다. 사용자가 kubectl을 통해 CLI 명령어를 입력하면 kube api server가 해당 명령어를 받게된다. 받은 다음 먼저, 해당 명령어가 권한이 있는지 그리고 유효한 명령인지를 확인한다. 그리고 유효하다면 ETCD 클러스터에서 해당 데이터를 가져오고 사용자가에게 응답해준다.
다른 예제를 통해 알아보자. 사용자가 pod를 생성하는 작업을 실행하면 아래의 순서대로 동작한다.
Authenticate User Validate Request Retrieve data Update ETCD Scheduler Kubelet</description></item><item><title>2-2 ETCD</title><link>https://ssungwxx.github.io/posts/cka/2-2-etcd/</link><pubDate>Sun, 06 Jun 2021 15:42:19 +0900</pubDate><guid>https://ssungwxx.github.io/posts/cka/2-2-etcd/</guid><description>ETCD란? 해당 강의에서는
ETCD is distributed reliable key-value store that is Simple, Secure&amp;amp;Fast.
라고 소개되었다. 현재 ETCD 홈페이지에는
A distributed, reliable key-value store for the most critical data of a distributed system
라고 소개되었다.
Key-value Store Key-value Store는 key 와 value 형태로 저장되는 데이터 베이스이다. 키의 중복은 허용되지 않으며 일반적인 상황의 데이터베이스로는 적합하지않다. 대신 Configuraion과 같은 데이터의 일부를 저장하기에는 적합하다. 왜냐하면 쓰기와 읽기 속도가 빠르기 때문이다.</description></item><item><title>2-1 Cluster Architecture</title><link>https://ssungwxx.github.io/posts/cka/2-1-cluster-architecture/</link><pubDate>Sun, 06 Jun 2021 14:40:52 +0900</pubDate><guid>https://ssungwxx.github.io/posts/cka/2-1-cluster-architecture/</guid><description>쿠버네티스의 클러스터 구조 시작하기에 앞서 해당 챕터에서는 쿠버네티스의 아키텍쳐를 고수준부터 설명을 하고 앞으로의 강의에서 좀 더 구체적으로 내려가며 각각의 컴포넌트들에 대해서 알아볼 것이다.
먼저, 각 클러스터의 각 컴포넌트들의 기능과 역할에 대해 알아본다. 쿠버네티스의 아키텍쳐를 선박들에 비유하며 설명할 예정이다.
Kuberntes 라는 명칭의 유래는 Helmsman(조타수)를 의미하는 그리스어에서 유래했다. 또한, Kubernetes는 Container Orchestration 이기 때문에 내부 클러스터들의 동작이 선박들이 움직이는 모습에 비유를 많이한다.
쿠버네티스에는 두가지의 선박들로 비유를 할 수 있다. 하나는 직접 바디를 건너 컨테이너를 옮기고 컨트롤 하는 Cargo ship(화물선), 다른 하나는 이러한 화물선들을 지켜보고 관리하는 Control ship이다.</description></item><item><title>1-2 Certification Detail</title><link>https://ssungwxx.github.io/posts/cka/1-2-certification-detail/</link><pubDate>Sun, 06 Jun 2021 00:10:56 +0900</pubDate><guid>https://ssungwxx.github.io/posts/cka/1-2-certification-detail/</guid><description>해당 강의에서는 시험시간을 3시간이라고 알려주었는데 바로 다음 노트에 2시간으로 변경되었다는 노트가 있다. 시험이 정기적으로 업데이트 되는 것 같으니 시험 보기전에 확인하고 준비한다음 신청하여 놀라지 않도록 조심해야겠다.
CKA 시험에 대한 자세한 정보는 여기에서 확인할 수 있다.</description></item><item><title>1-1 Course Introduction</title><link>https://ssungwxx.github.io/posts/cka/1-1-course-introduction/</link><pubDate>Sat, 05 Jun 2021 23:32:19 +0900</pubDate><guid>https://ssungwxx.github.io/posts/cka/1-1-course-introduction/</guid><description>Udemy CKA 강좌 소개 및 설명 해당 강좌는 CKA 자격증 취득만을 위한 강좌는 아니다. 관련된 몇 가지 주제들을 다룰 것이고 강의는 크게 아래와 같은 섹션으로 구분된다.
Core concepts Scheduling Logging Monitoring Application lifecycle management Cluster maintenance Security Storage Networking Installation, Configuration &amp;amp; Validation Troubleshooting</description></item><item><title>0-0 Why Start CKA Study Start</title><link>https://ssungwxx.github.io/posts/cka/0-0-why-start-cka-start/</link><pubDate>Fri, 04 Jun 2021 22:43:24 +0900</pubDate><guid>https://ssungwxx.github.io/posts/cka/0-0-why-start-cka-start/</guid><description>왜 CKA 공부를 시작하는가? 취업을 시작할 때 나의 희망 도매인은 막연히 MSA를 사용하는 무언가였다. 그저 모놀리틱한 프로젝트만 해본 나로서는 단순이 FE와 BE가 분산된 것이 아닌 다양한 역할의 서버들이 분산되어 동작하는 것에 호기심을 느꼈기 때문이다. 면접을 가서는 이러한 점을 적극 어필하였다. 그렇게 카카오 겨울 인턴에서 운좋게도 클라우드 팀을 만나게되었고 최종 합격하여 인턴으로 근무도 하였다.
클라우드팀에서 근무하면서 모든걸 새로 시작하였다. Golang부터 시작해서 Docker, Kubernetes, 여러가지의 오픈소스들 모두 처음 접하는 것들 뿐이였다. 하다보니 제일 매력을 느낀 것은 Kubernetes 였다.</description></item></channel></rss>